<!DOCTYPE html>

<head>
    <title>Map Plotter</title>
    <link rel="icon" href="./images/icons/icon_16x16.png" sizes="16x16" type="image/png" />
    <link rel="icon" href="./images/icons/icon_32x32.png" sizes="32x32" type="image/png" />
    <link rel="icon" href="./images/icons/icon_64x64.png" sizes="64x64" type="image/png" />
    <link rel="icon" href="./images/icons/icon_128x128.png" sizes="128x128" type="image/png" />
    <meta name="author" content="Tsuyoshi Ohta">
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta content="width=device-width,
                initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- <script src="https://unpkg.com/d3"></script> -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- <script src="https://unpkg.com/d3fc"></script> -->
    <script src="https://unpkg.com/d3fc@15.0.8/build/d3fc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.6.0/dist/leaflet.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" />
    <!-- for semantic ui -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
    <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="./outputHTML.js"></script>

    <!--  色変換の関数定義 -->
    <script>
        //The steps in the jet colorscale
        const jet_data_lin = [
            [0, 0, 0.5],
            [0, 0, 1],
            [0, 0.5, 1],
            [0, 1, 1],
            [0.5, 1, 0.5],
            [1, 1, 0],
            [1, 0.5, 0],
            [1, 0, 0],
            [0.5, 0, 0]
        ]

        const jet_rgb = jet_data_lin.map(x => {
            return d3.rgb.apply(null, x.map(y => y * 255))
        })

        jetInterpList = new Array(jet_rgb.length - 1);
        for (let i = 0; i < jet_rgb.length - 1; i++) {
            jetInterpList[i] = d3.interpolateRgb(jet_rgb[i], jet_rgb[i + 1])
        }

        function interpJet(pow) {
            if (!(0 <= pow && pow <= 1)) return "rgb(0, 0, 0)";

            const n = jet_rgb.length - 1;

            var i = Math.max(0, Math.min(n - 1, Math.floor(pow *= n)));
            return jetInterpList[i](pow - i);
        };
    </script>

    <!-- その他関数の定義 -->
    <script>
        // 関数定義
        function norm(x, min, max) { // 電力値の正規化
            if (x > max) return 1;
            if (x < min) return 0;
            return (x - min) / (max - min);
        };
        function readCsv(data) {
            var csv = $.csv.toArrays(data);
        };
        function getInterpolationFunc(interpolateTheme, reverseHeatmap) {
            let f = function () { };
            switch (interpolateTheme) {
                case "red-blue":
                    f = d3.interpolateRdBu;
                    break;

                case "red":
                    f = d3.interpolateReds;
                    break;

                case "blue":
                    f = d3.interpolateBlues;
                    break;

                case "green":
                    f = d3.interpolateGreens;
                    break;

                case "grey":
                    f = d3.interpolateGreys;
                    break;

                case "orange":
                    f = d3.interpolateOranges;
                    break;

                case "spectral":
                    f = d3.interpolateSpectral;
                    break;

                case "viridis":
                    f = d3.interpolateViridis;
                    break;

                case "inferno":
                    f = d3.interpolateInferno;
                    break;

                case "plasma":
                    f = d3.interpolatePlasma;
                    break;

                case "cool":
                    f = d3.interpolateCool;
                    break;

                case "jet":
                    f = interpJet;
                    break;

                default:
                    f = d3.interpolateSpectral;
            }

            if (reverseHeatmap) {
                return function (x) { return f(1 - x) };
            } else {
                return f;
            }
        };
        function cvtPow2Color(pow, min, max, interpolateTheme, reverseHeatmap) {
            return getInterpolationFunc(interpolateTheme, reverseHeatmap)(norm(pow, min, max));
        };
        function updateColorbar(powMin, powMax, interpolateTheme, reverseHeatmap) { // カラーバーの更新
            $("#colorbar-container").empty();

            const domain = [powMin, powMax]; // カラーバーの値のレンジ
            const height = Math.floor(38 * $(window).height() / 100);
            const width = 200;
            const svgWidth = 130;

            // カラーバーの上下部にゆとりを持たせる.
            const paddedDomain = fc.extentLinear()
                .pad([0.1, 0.1])
                .padUnit("percent")(domain);
            const [min, max] = paddedDomain;
            const expandedDomain = d3.range(min, max, (max - min) / height);

            // Band scale for x-axis
            const xScale = d3
                .scaleBand()
                .domain([0, 1])
                .range([0, width]);

            // Linear scale for y-axis
            const yScale = d3
                .scaleLinear()
                .domain(paddedDomain)
                .range([height, 0]);

            const svgBar = fc
                .autoBandwidth(fc.seriesSvgBar())
                .xScale(xScale)
                .yScale(yScale)
                .crossValue(0)
                .baseValue((_, i) => (i > 0 ? expandedDomain[i - 1] : 0))
                .mainValue(d => d)
                .decorate(selection => {
                    selection.selectAll("path").style("fill", d => getInterpolationFunc(interpolateTheme, reverseHeatmap)(norm(d, ...domain)));
                    // selection.selectAll("path").style("fill", d => d3.interpolateSpectral(norm(d, ...domain)));
                    // selection.selectAll("path").style("fill", d => console.log(d));
                });

            // Drawing the legend bar
            const legendSvg = d3.select("#colorbar-container").append("svg")
                .attr("height", height)
                .attr("width", svgWidth)
                .attr("viewBox", `0, 0, ${svgWidth}, ${height}`)
                .attr("id", "colorbar");
            const legendBar = legendSvg
                .append("g")
                .datum(expandedDomain)
                .call(svgBar);

            tickValues = [...domain,
            domain[0] + (domain[1] - domain[0]) / 5,
            domain[0] + 2 * (domain[1] - domain[0]) / 5,
            domain[0] + 3 * (domain[1] - domain[0]) / 5,
            domain[0] + 4 * (domain[1] - domain[0]) / 5]

            // Removing the outer ticks
            const axisLabel = fc
                .axisRight(yScale)
                .tickValues(tickValues)
                .tickSizeOuter(0)
                .decorate((s) =>
                    s.enter()
                        .select("text")
                        .style("font-size", "20"));

            // Drawing and translating the label
            const barWidth = Math.abs(legendBar.node().getBBox().x);
            legendSvg.append("g")
                .attr("transform", `translate(${barWidth})`)
                .datum(expandedDomain)
                .call(axisLabel);

            // Hiding the vertical line
            legendSvg.append("g")
                .attr("transform", `translate(${barWidth})`)
                .datum(expandedDomain)
                .call(axisLabel)
                .select(".domain")
                .attr("visibility", "hidden");

            $(window).off('resize');
            $(window).on('resize', function () {
                legendSvg.attr("height", Math.floor(38 * $(window).height() / 100));
            });

        }
    </script>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map-container {
            position: relative;
            width: 100.0%;
            height: 100.0%;
            left: 0;
            top: 0;
            z-index: 0;
        }
    </style>
</head>

<body>
    <!-- leafletのマップ -->
    <div class="folium-map" id="map-container"></div>

    <!-- プロット関連のモーダルウィンドウの表示ボタン -->
    <div id="opt-button-container">
        <a class="plot-modal-open" href="">Plot</a>
        <a class="move-modal-open" href="">Move</a>
        <a class="tile-modal-open" href="">Tile</a>
        <a id="save-button" href="">Save</a>
        <a id="save-button" target="_blank"
            href="https://www.notion.so/Map-Plotter-19aebd0ef33647f0ad13f47ac8133b9b">Usage</a>
    </div>

    <div id="colorbar-container"></div>

    <!-- 描画のモーダルウィンドウ -->
    <div class="modal-container plot-modal-container">
        <div class="modal-bg plot-modal-close"></div>
        <div class="modal-content">
            <form id="plot-opt-form">
                <div id="outer-file-input-container">
                    <input type="file" id="file-input" />
                    <div id="file-input-drop-box">
                        <div>ファイルをここにドロップ</div>
                    </div>
                    <span class="" id="file-input-container">
                        ファイルを選択
                    </span>
                    <span id="select-file-name">ファイルが選択されていません</span>
                </div>

                <div class="form-divider"></div>

                <fieldset class="select-column">
                    <legend>カラムの選択</legend>

                    <div class="input-container">
                        <label><span id="req-red">(必須)</span>緯度(Latitude)の列</label>
                        <select class="have-ul index-selector" required id="lat-index-selector" disabled></select>
                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label><span id="req-red">(必須)</span>経度(Longitude)の列</label>
                        <select class="have-ul index-selector" required id="lng-index-selector" disabled></select>
                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label><span id="req-red">(必須)</span>描画したい値の列</label>
                        <select class="have-ul index-selector" required id="pow-index-selector" disabled></select>
                        <div class="form-underline"></div>
                    </div>
                </fieldset>

                <div class="form-divider"></div>

                <fieldset class="edit-plot">
                    <legend>描画の設定</legend>

                    <div class="action-button-container">
                        <a href="" class="disable" id="calc-minmax">最小値と最大値を算出</a>
                    </div>

                    <div class="input-container">
                        <label><span id="req-red">(必須)</span>カラーバー最小値</label>
                        <input type="number" class="have-ul" required id="pow-min-input" value="-130"
                            placeholder="カラーバー最低値" />
                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label><span id="req-red">(必須)</span>カラーバー最大値</label>
                        <input type="number" class="have-ul" required id="pow-max-input" value="-90"
                            placeholder="カラーバー最大値" />
                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label>描画点の大きさ</label>

                        <select class="have-ul" required id="radius-selector">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5" selected>5</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                            <option value="30">30</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                            <option value="500">500</option>
                            <option value="1000">1000</option>
                            <option value="5000">5000</option>
                            <option value="20000">20000</option>
                        </select>

                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label>描画閾値 (この値以上の点のみ描画される)</label>
                        <input type="number" class="have-ul" id="threshold-input" value="" placeholder="閾値" />
                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label>データの間引き</label>

                        <select class="have-ul" id="step-selector">
                            <option value="1" selected>そのまま</option>
                            <option value="2">1/2</option>
                            <option value="3">1/3</option>
                            <option value="4">1/4</option>
                            <option value="5">1/5</option>
                            <option value="10">1/10</option>
                            <option value="15">1/15</option>
                            <option value="20">1/20</option>
                            <option value="30">1/30</option>
                            <option value="50">1/50</option>
                            <option value="100">1/100</option>
                            <option value="200">1/200</option>
                            <option value="500">1/500</option>
                            <option value="1000">1/1000</option>
                        </select>

                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label>NaNの点(値の無い点)を描画</label>
                        <input type="checkbox" class="have-ul" id="plot-nan-input" checked />
                        <label for="plot-nan-input">する</label>
                        <div class="form-underline"></div>
                    </div>
                </fieldset>

                <div class="form-divider"></div>

                <fieldset class="edit-plot-point">
                    <legend>描画点の設定</legend>

                    <div class="input-container">
                        <label>円の塗りつぶしを</label>
                        <input type="checkbox" class="have-ul" id="fill-circle-input" checked />
                        <label for="fill-circle-input">する</label>
                        <div class="form-underline"></div>
                    </div>

                    <div class="input-container">
                        <label>枠線の幅</label>

                        <select class="have-ul" id="stroke-width-selector">
                            <option value="1" selected>1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                            <option value="30">30</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                            <option value="200">200</option>
                        </select>

                        <div class="form-underline"></div>
                    </div>

                    <div class="input-container">
                        <label>塗りつぶしの不透明度</label>

                        <select class="have-ul" id="fill-opacity-selector">
                            <option value="0">0</option>
                            <option value="0.1">0.1</option>
                            <option value="0.2">0.2</option>
                            <option value="0.3">0.3</option>
                            <option value="0.4">0.4</option>
                            <option value="0.5">0.5</option>
                            <option value="0.6">0.6</option>
                            <option value="0.7">0.7</option>
                            <option value="0.8">0.8</option>
                            <option value="0.9">0.9</option>
                            <option value="1.0" selected>1.0</option>
                        </select>

                        <div class="form-underline"></div>
                    </div>

                    <div class="input-container">
                        <label>枠線の不透明度</label>

                        <select class="have-ul" id="stroke-opacity-selector">
                            <option value="0">0</option>
                            <option value="0.1">0.1</option>
                            <option value="0.2">0.2</option>
                            <option value="0.3">0.3</option>
                            <option value="0.4">0.4</option>
                            <option value="0.5">0.5</option>
                            <option value="0.6">0.6</option>
                            <option value="0.7">0.7</option>
                            <option value="0.8">0.8</option>
                            <option value="0.9">0.9</option>
                            <option value="1.0" selected>1.0</option>
                        </select>

                        <div class="form-underline"></div>
                    </div>
                </fieldset>

                <div class="form-divider"></div>

                <fieldset class="edit-heatmap">
                    <legend>ヒートマップの設定</legend>

                    <div class="input-container">
                        <label>ヒートマップテーマの選択</label>

                        <select class="have-ul" required id="theme-selector">
                            <option value="red-blue">Red → Blue</option>
                            <option value="red">Red</option>
                            <option value="blue">Blue</option>
                            <option value="green">Green</option>
                            <option value="grey">Grey</option>
                            <option value="orange">Orange</option>
                            <option value="spectral">spectral</option>
                            <option value="viridis">viridis</option>
                            <option value="inferno">inferno</option>
                            <option value="plasma">plasma</option>
                            <option value="cool">cool</option>
                            <option value="jet" selected>jet</option>
                        </select>

                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label>ヒートマップの向きは</label>
                        <input type="checkbox" class="have-ul" id="reverse-heatmap-input" />
                        <label for="reverse-heatmap-input">順方向</label>
                        <div class="form-underline"></div>
                    </div>
                </fieldset>

                <div class="form-divider"></div>

                <fieldset class="edit-noise">
                    <legend>ノイズの設定</legend>

                    <div class="input-container">
                        <label>ノイズの列</label>
                        <select class="have-ul index-selector" id="noise-index-selector" disabled></select>
                        <div class="form-underline"></div>
                    </div>
                    <div class="input-container">
                        <label><span id="req-red"></span>信号ノイズ差([電力-ノイズ]がこの値以上だと描画される)</label>
                        <input type="number" class="have-ul" required id="noise-diff-input" value=""
                            placeholder="信号ノイズ差" disabled />
                        <div class="form-underline"></div>
                    </div>
                </fieldset>

                <div class="form-divider"></div>

                <fieldset class="edit-noise">
                    <legend>方位角の設定</legend>

                    <div class="input-container">
                        <label>方位角の列</label>
                        <select class="have-ul index-selector" id="angle-index-selector" disabled></select>
                        <div class="form-underline"></div>
                    </div>

                    <div class="input-container">
                        <label>マーカータイプ</label>
                        <select class="have-ul" required id="angle-marker-selector" disabled>
                            <option value="v2-normal">v2</option>
                            <option value="v3-normal" selected>v3 (normal)</option>
                            <option value="v3-short">v3 (short)</option>
                        </select>
                        <div class="form-underline"></div>
                    </div>

                    <div class="input-container">
                        <label><span id="req-red"></span>線の太さ</label>
                        <input type="number" class="have-ul" required id="angle-marker-lw-input" value="3" min="0.1"
                            step="0.1" placeholder="0.1以上の値" disabled />
                        <div class="form-underline"></div>
                    </div>

                    <div class="input-container">
                        <label><span id="req-red"></span>点の大きさ</label>
                        <input type="number" class="have-ul" required id="angle-marker-pr-input" value="4" min="0.1"
                            step="0.1" placeholder="0.1以上の値" disabled />
                        <div class="form-underline"></div>
                    </div>
                </fieldset>


                <div id="decide-button-container">
                    <input type="button" id="decide-button" value="プロットする" disabled />
                </div>

            </form>
            <div id="modal-close-button">
                <a class="plot-modal-close" href="">閉じる</a>
            </div>
        </div>
    </div>

    <!-- 移動のモーダルウィンドウ -->
    <div class="modal-container move-modal-container">
        <div class="modal-bg move-modal-close"></div>
        <div class="modal-content">
            <div id="now-pos">
                <div class="lat">
                    <div class="name">緯度(Latitude)</div>
                    <div class="value">XXX</div>
                </div>
                <div class="lng">
                    <div class="name">経度(Longitude)</div>
                    <div class="value">YYY</div>
                </div>
            </div>

            <div class="form-divider"></div>


            <fieldset>
                <legend>指定した位置へ移動</legend>

                <div class="input-container">
                    <label>緯度</label>
                    <input type="number" class="have-ul" id="lat-input" value="" placeholder="緯度" />
                    <div class="form-underline"></div>
                </div>
                <div class="input-container">
                    <label>経度</label>
                    <input type="number" class="have-ul" id="lng-input" value="" placeholder="経度" />
                    <div class="form-underline"></div>
                </div>
                <div class="decide-move-button">
                    <a id="move-specified-pos" href="">移動</a>
                </div>
            </fieldset>

            <div class="form-divider"></div>

            <fieldset>
                <legend>描画初期位置へ移動</legend>

                <div class="decide-move-button">
                    <a id="reset-pos-button" href="">移動</a>
                </div>
            </fieldset>

            <div id="modal-close-button">
                <a class="move-modal-close" href="">閉じる</a>
            </div>
        </div>
    </div>

    <!-- タイルのモーダルウィンドウ -->
    <div class="lower-modal-container tile-modal-container">
        <div class="modal-bg tile-modal-close"></div>
        <div class="modal-content">
            <fieldset>
                <legend>各タイルの不透過率</legend>

                <div id="opacity-input-container">

                </div>
            </fieldset>

            <div id="modal-close-button">
                <a class="tile-modal-close" href="">閉じる</a>
            </div>
        </div>
    </div>
</body>

<!-- HTML要素の挿入 -->
<script>
    // 不透過率の挿入
    const getOpacityInputContainer = function (label) {
        return `
<div class="input-container">
<label>${label}</label>
<select class="have-ul">
<option value="0.0">0.0</option>
<option value="0.1">0.1</option>
<option value="0.2">0.2</option>
<option value="0.3">0.3</option>
<option value="0.4">0.4</option>
<option value="0.5" selected>0.5</option>
<option value="0.6">0.6</option>
<option value="0.7">0.7</option>
<option value="0.8">0.8</option>
<option value="0.9">0.9</option>
<option value="1.0">1.0</option>
</select>
<div class="form-underline"></div>
</div>
`
    };
    const labelArr = ["国土地理院:淡色地図", "国土地理院:標準地図", "国土地理院:白地図", "国土地理院:色別標高図", "国土地理院:写真", "国土地理院:陰影起伏図", "OSM", "OSM-Toner"]
    document.getElementById("opacity-input-container").innerHTML = labelArr.map(getOpacityInputContainer).join("");
</script>

<!-- ファイル読み込み時の動作 -->
<script>
    // file-inputボタンのイベント設定 : CSVの読み込み, header取得
    const file = $("#file-input");
    // var file = document.getElementById('file-input');

    // HTML5 のFile APIに対応している場合
    if (window.File && window.FileReader && window.FileList && window.Blob) {
        function loadLocalCsv(target) {
            // ファイルデータ取得
            var fileData = target.prop("files")[0];
            // var fileData = e.target.files[0];

            if ($("#file-input").val().length == 0) {
                // セレクタを無効化
                $(".index-selector").prop("disabled", false);
                return;
            }

            // CSVファイルチェック
            if (!fileData.name.match('.csv$')) {
                alert('CSVファイルを選択してください');
                return;
            }

            // ファイル読み込み時の処理を書く
            // ファイル読み込みに成功時、カンマ区切りを配列に加工
            var reader = new FileReader();
            reader.onload = function () {
                var cols = reader.result.replace(/\r\n?/g, "\n").split("\n");
                var data = [];
                for (var i = 0; i < cols.length; i++) {
                    const vals = cols[i].split(',');
                    if (vals.length >= 3) {
                        data[i] = vals;
                    }
                }

                // 「カラムの選択」: セレクタの中身を消す
                $(".index-selector").empty();

                // 「カラムの選択」: セレクタを有効化
                $(".index-selector").prop("disabled", false).change();

                // 「カラムの選択」: セレクタの内容を追加 (CSVのカラム名)
                $(".index-selector").append($("<option>").val("").text("利用するカラムを選択"));
                for (let i = 0; i < data[0].length; i++) {
                    $(".index-selector").append($("<option>").val(i).text(data[0][i]));
                    if (data[0][i] == "Latitude") {
                        $("#lat-index-selector").val(i);
                    }
                    if (data[0][i] == "Longitude") {
                        $("#lng-index-selector").val(i);
                    }
                }

                // 「描画の設定」: 最小値と最大値を算出するボタンの挙動
                $('#calc-minmax').on('click', function () {
                    const powIndex = parseInt($("#pow-index-selector").val());
                    let [min_v, max_v] = getMinMax(data, powIndex);
                    $("#pow-min-input").val(min_v)
                    $("#pow-max-input").val(max_v)
                    return false;
                });

                // 決定ボタンの挙動を加える
                $('#decide-button').off("click"); // onによるイベントの追加は上書きでないため, 一旦古いものを削除
                $('#decide-button').on("click", function () {
                    $('#map-container svg g').empty();
                    $('#map-container > div.leaflet-pane.leaflet-map-pane > div.leaflet-pane.leaflet-marker-pane').empty()

                    $('.plot-modal-container').fadeOut();

                    const latIndex = parseInt($("#lat-index-selector").val());
                    const lngIndex = parseInt($("#lng-index-selector").val());
                    const powIndex = parseInt($("#pow-index-selector").val());

                    const powMin = parseInt($("#pow-min-input").val());
                    const powMax = parseInt($("#pow-max-input").val());

                    const radius = parseInt($("#radius-selector").val());
                    const threshold = parseFloat($("#threshold-input").val());
                    const step = parseInt($("#step-selector").val());
                    const plotNan = $("#plot-nan-input").prop("checked");

                    const fillCircle = $("#fill-circle-input").prop("checked");
                    const strokeWidth = parseInt($("#stroke-width-selector").val());
                    const fillOpacity = parseFloat($("#fill-opacity-selector").val());
                    const strokeOpacity = parseFloat($("#stroke-opacity-selector").val());

                    const interpolateTheme = $("#theme-selector").val();
                    const reverseHeatmap = $("#reverse-heatmap-input").prop("checked");

                    const noiseIndex = ($("#noise-diff-input").prop("disabled") ? -1 : parseInt($("#noise-index-selector").val()));
                    const noiseDiff = ($("#noise-diff-input").prop("disabled") ? 0 : parseFloat($("#noise-diff-input").val()));

                    if ($("#angle-index-selector").val() == "" || $("#angle-index-selector").val() == null) {
                        // 点の描画
                        plotAllCircles(data, step, latIndex, lngIndex, powIndex, powMin, powMax, threshold, plotNan, fillCircle, strokeWidth, fillOpacity, strokeOpacity, radius, interpolateTheme, reverseHeatmap, noiseIndex, noiseDiff);
                    } else {
                        // 矢印の値が選択されていれば矢印を描画
                        const angIndex = parseInt($("#angle-index-selector").val());
                        const angMarker = $("#angle-marker-selector").val();
                        const angMarkerLineWidth = parseFloat($("#angle-marker-lw-input").val());
                        const angMarkerPointRadius = parseFloat($("#angle-marker-pr-input").val());
                        plotAllArrows(data, step, latIndex, lngIndex, powIndex, powMin, powMax, threshold, plotNan, fillCircle, strokeWidth, fillOpacity, strokeOpacity, radius, interpolateTheme, reverseHeatmap, noiseIndex, noiseDiff, angIndex, angMarker, angMarkerLineWidth, angMarkerPointRadius);
                    }

                    // カラーバーの作製/更新
                    updateColorbar(powMin, powMax, interpolateTheme, reverseHeatmap);

                    // 初期位置ボタンの挙動追加
                    $('#reset-pos-button').off("click");
                    $('#reset-pos-button').on("click", function () {
                        resetPos(data[1][latIndex], data[1][lngIndex]);
                        return false;
                    });

                    // 保存ボタンの挙動変更
                    const opacity = 0.3;
                    $('#save-button').off("click");
                    $('#save-button').on("click", function () {
                        // 初期位置は描画位置に変更する
                        outputHTML(data, powMin, powMax, radius, threshold, plotNan, opacity, interpolateTheme, reverseHeatmap, latIndex, lngIndex, powIndex, noiseIndex, noiseDiff, data[1][latIndex], data[1][lngIndex], 14);
                        return false;
                    });

                    resetPos(data[1][latIndex], data[1][lngIndex]);

                    // カラーバーのコンテナ表示
                    $("#colorbar-container").fadeTo(500, 1);

                    updateTiles(getNowOpacity());

                    return false;
                });
            }

            // ファイル読み込みを実行
            reader.readAsText(fileData);
        };
        file.on("change", function () {
            if ($(this).prop('files').length == 0) {
                $("#select-file-name").text("ファイルが選択されていません");
            } else {
                var file_name = $(this).prop('files')[0].name;
                $("#select-file-name").text(file_name);
            }
            loadLocalCsv($(this));
        });
        file.on("click", function () {
            $(this).val('');
        });

    } else {
        // file.style.display = 'none';
        file.css("display", "none");
        result.innerHTML = 'File APIに対応したブラウザでご確認ください';
    }
</script>

<!-- マップへの処理 -->
<script>
    // ------ マップ描画関係 ------
    const initPos = [35.7, 139.75];
    const initOpacity = [0.3, 0.3, 0.3, 0.3, 0.8, 0.3, 0.4, 0.3];

    // モーダルウィンドウ内の透明度の項目選択
    initOpacity.forEach(function (element, i) {
        $(`#opacity-input-container>.input-container:nth-child(${i + 1}) select`).val(element);
    });

    // マップインスタンス生成
    let map = L.map(
        "map-container",
        {
            center: initPos,
            crs: L.CRS.EPSG3857,
            zoom: 13,
            zoomControl: true,
            preferCanvas: false,
            // preferCanvas: true,
        }
    );

    // タイルレイヤーの追加とレイヤーコントローラの追加
    let baseLayers = {};
    let overLayers = getTilesDict(initOpacity);
    let layersControl = L.control.layers(baseLayers, overLayers).addTo(map);

    $(function () {

        // 縮尺の表示
        L.control.scale({
            imperial: true,
            metric: true
        }).addTo(map);

        // 初期位置の緯度経度を記述
        describeNowLatLng(map.getCenter());

        // ズームコントローラの追加
        map.zoomControl.setPosition("bottomright");

        // 初期位置ボタンの挙動追加
        $('#reset-pos-button').off("click");
        $('#reset-pos-button').on("click", function () {
            resetPos(...initPos);
            return false;
        });

        // 保存ボタンの挙動変更
        $('#save-button').off("click");
        $('#save-button').on("click", function () {
            // 地図が更新されるのを防ぐため挿入.
            return false;
        });

        // 初期タイル選択
        $("div.leaflet-control-layers-overlays input[type='checkbox']").eq(4).trigger("click");
        $("div.leaflet-control-layers-overlays input[type='checkbox']").eq(6).trigger("click");

        // ------ マップイベントに対する
        map.on('moveend', function (e) {
            describeNowLatLng(this.getCenter());
        });
    });

    // 現在の緯度経度を記述
    function describeNowLatLng(center) {
        $("#now-pos .lat .value").text(center.lat);
        $("#now-pos .lng .value").text(center.lng);
    }


    // タイルの取得
    function getTilesDict(opacityArray) {
        return {
            "国土地理院:淡色地図": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png", {
                "attribution": "<a href='http://maps.gsi.go.jp/development/ichiran.html'>地理院タイル</a>",
                "detectRetina": false, "maxNativeZoom": 18, "maxZoom": 18, "minZoom": 0, "noWrap": false, "opacity": opacityArray[0], "subdomains": "abc", "tms": false
            }),
            "国土地理院:標準地図": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png", {
                "attribution": "<a href='http://maps.gsi.go.jp/development/ichiran.html'>地理院タイル</a>",
                "opacity": opacityArray[1]
            }),
            "国土地理院:白地図": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/blank/{z}/{x}/{y}.png", {
                "attribution": "<a href='http://maps.gsi.go.jp/development/ichiran.html'>地理院タイル</a>",
                "maxNativeZoom": 14, "maxZoom": 14, "minZoom": 6, "opacity": opacityArray[2]
            }),
            "国土地理院:色別標高図": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/relief/{z}/{x}/{y}.png", {
                "attribution": "<a href='http://maps.gsi.go.jp/development/ichiran.html'>地理院タイル. 海域部は海上保安庁海洋情報部の資料を使用して作成.</a>",
                "maxNativeZoom": 15, "maxZoom": 15, "minZoom": 6, "opacity": opacityArray[3]
            }),
            "国土地理院:写真": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg", {
                "attribution": "<a href='http://maps.gsi.go.jp/development/ichiran.html'>地理院タイル</a><br>データソース：Landsat8画像（GSI,TSIC,GEO Grid/AIST）, Landsat8画像（courtesy of the U.S. Geological Survey）, 海底地形（GEBCO）",
                "maxNativeZoom": 18, "maxZoom": 18, "minZoom": 9, "opacity": opacityArray[4]
            }),
            "国土地理院:陰影起伏図": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png", {
                "attribution": "<a href='http://maps.gsi.go.jp/development/ichiran.html'>地理院タイル</a>",
                "maxNativeZoom": 16, "maxZoom": 16, "minZoom": 6, "opacity": opacityArray[5]
            }),
            "OSM": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                "attribution": "&copy; <a href='http://osm.org/copyright'>OpenStreetMap</a> contributors",
                "detectRetina": false, "maxNativeZoom": 18, "maxZoom": 18, "minZoom": 0, "noWrap": false, "opacity": opacityArray[6], "subdomains": "abc", "tms": false
            }),
            "OSM-Toner": L.tileLayer("https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png", {
                "attribution": "Map tiles by \u003ca href=\"http://stamen.com\"\u003eStamen Design\u003c/a\u003e, under \u003ca href=\"http://creativecommons.org/licenses/by/3.0\"\u003eCC BY 3.0\u003c/a\u003e. Data by \u0026copy; \u003ca href=\"http://openstreetmap.org\"\u003eOpenStreetMap\u003c/a\u003e, under \u003ca href=\"http://www.openstreetmap.org/copyright\"\u003eODbL\u003c/a\u003e.",
                "detectRetina": false, "maxNativeZoom": 18, "maxZoom": 18, "minZoom": 0, "noWrap": false, "opacity": opacityArray[7], "subdomains": "abc", "tms": false
            })
        }
    }

    // タイルの更新(選択中のタイルを引き継ぐ)
    function updateTiles(opacityArray) {
        const layerNum = Object.keys(overLayers).length;
        let checkedList = Array(layerNum);

        // 現在選択中のレイヤを判別
        for (let idx = 0; idx < layerNum; idx++) {
            checkedList[idx] = $("div.leaflet-control-layers-overlays input[type='checkbox']").eq(idx).prop('checked');
        }

        // 描画中のタイルレイヤーの削除
        for (let key in overLayers) {
            if (map.hasLayer(overLayers[key])) map.removeLayer(overLayers[key]);
        }

        // レイヤーコントローラーの削除と更新
        layersControl.remove();
        overLayers = getTilesDict(opacityArray);
        layersControl = L.control.layers(baseLayers, overLayers).addTo(map);

        // レイヤを選択する
        for (let idx = 0; idx < layerNum; idx++) {
            if (checkedList[idx]) $("div.leaflet-control-layers-overlays input[type='checkbox']").eq(idx).trigger("click");
        }
    }

    // 円のプロットのための関数
    function plotAllCircles(data, step, latIndex, lngIndex, powIndex, powMin, powMax, threshold, plotNan, fillCircle, strokeWidth, fillOpacity, strokeOpacity, radius, interpolateTheme, reverseHeatmap, noiseIndex, noiseDiff) {
        for (let i = 1; i < data.length; i += step) {
            if (data[i].length < 3) {
                continue;
            }

            // 点を描画するかどうかのチェック
            if (data[i][powIndex] < threshold) { // thresholdによるチェック (ちなみにthreshold is NaN なら Falseになる)
                continue;
            } else if (!plotNan && isNaN(data[i][powIndex])) {
                continue;
            } else if (!plotNan && (data[i][powIndex].length == 0)) {
                continue;
            }

            const lat = parseFloat(data[i][latIndex]);
            const lng = parseFloat(data[i][lngIndex]);
            const pow = parseFloat(data[i][powIndex]);

            // ノイズとの差のチェック, index=-1の時, チェックしない.
            // 電力の方がNaNのときは描画する
            if (noiseIndex >= 0) {
                const noise = parseFloat(data[i][noiseIndex]);
                if ((pow - noise) < noiseDiff) {
                    continue;
                }
            }

            const color = cvtPow2Color(pow, powMin, powMax, interpolateTheme, reverseHeatmap);

            c = L.circle(
                [lat, lng],
                {
                    "bubblingMouseEvents": true,
                    "color": color,
                    "dashArray": null,
                    "dashOffset": null,
                    "fill": fillCircle,
                    "fillColor": color,
                    "fillOpacity": fillOpacity,
                    "fillRule": "evenodd",
                    "lineCap": "round",
                    "lineJoin": "round",
                    "opacity": strokeOpacity,
                    "radius": radius,
                    "stroke": true,
                    "weight": strokeWidth
                }
            ).addTo(map);

            c.bindPopup(`緯度 : ${lat}<br>経度 : ${lng}<br>値 : ${pow}`);
            c.on("mouseover", function (e) {
                this.openPopup();
            });
            c.on("mouseout", function (e) {
                this.closePopup();
            });
        }
    };

    // 矢印のプロットのための関数
    function plotAllArrows(data, step, latIndex, lngIndex, powIndex, powMin, powMax, threshold, plotNan, fillCircle, strokeWidth, fillOpacity, strokeOpacity, radius, interpolateTheme, reverseHeatmap, noiseIndex, noiseDiff, angIndex, angMarker, angMarkerLineWidth, angMarkerPointRadius) {
        for (let i = 1; i < data.length; i += step) {
            if (data[i].length < 3) {
                continue;
            }

            // 点を描画するかどうかのチェック
            if (data[i][powIndex] < threshold) { // thresholdによるチェック (ちなみにthreshold is NaN なら Falseになる)
                continue;
            } else if (!plotNan && isNaN(data[i][powIndex])) {
                continue;
            } else if (!plotNan && (data[i][powIndex].length == 0)) {
                continue;
            }

            const lat = parseFloat(data[i][latIndex]);
            const lng = parseFloat(data[i][lngIndex]);
            const pow = parseFloat(data[i][powIndex]);
            const ang = parseFloat(data[i][angIndex]);

            // ノイズとの差のチェック, index=-1の時, チェックしない.
            // 電力の方がNaNのときは描画する
            if (noiseIndex >= 0) {
                const noise = parseFloat(data[i][noiseIndex]);
                if ((pow - noise) < noiseDiff) {
                    continue;
                }
            }

            const color = cvtPow2Color(pow, powMin, powMax, interpolateTheme, reverseHeatmap);

            // 各マーカーのSVGを設定
            let svgMarker = "";
            if (angMarker === "v2-normal") {
                svgMarker = `
<svg 
  viewBox="0 0 48 48" 
  fill="none" 
>
  <g transform="rotate(${ang}, 24, 24)">
    <path
     d="m 36,24.019918 c 0,-8.73 -12,-20.6800002 -12,-20.6800002 0,0 -12,11.9500002 -12,20.6800002 a 12,12 0 0 0 24,0 z"
     fill="none"
     stroke="${color}"
     stroke-linecap="round"
     stroke-linejoin="round"
     stroke-width="${angMarkerLineWidth}" />
  <circle
     cx="24"
     cy="24"
     r="${angMarkerPointRadius}"
     fill="${color}" />
  </g>
</svg>`;
            } else if (angMarker === "v3-normal") {
                svgMarker = `
<svg 
  viewBox="0 0 48 48" 
  fill="none" 
>
  <g transform="rotate(${ang}, 24, 24)">
    <circle
       fill="${color}"
       r="${angMarkerPointRadius}"
       cy="24"
       cx="24" />
    <path
       stroke-linejoin="round"
       stroke-linecap="round"
       stroke-width="${angMarkerLineWidth}"
       stroke="${color}"
       d="M 24,2 V 24" />
    <path
       stroke-linejoin="round"
       stroke-linecap="round"
       stroke-width="${angMarkerLineWidth}"
       stroke="${color}"
       d="m 17,9.1 7,-7.5 7,7.5" />
  </g>
</svg>`;;
            } else if (angMarker === "v3-short") {
                svgMarker = `
<svg 
  viewBox="0 0 48 48" 
  fill="none" 
>
  <g transform="rotate(${ang}, 24, 24)">
    <circle
       fill="${color}"
       r="${angMarkerPointRadius}"
       cy="24"
       cx="24" />
    <path
       stroke-linejoin="round"
       stroke-linecap="round"
       stroke-width="${angMarkerLineWidth}"
       stroke="${color}"
       d="M 24,8.8 V 24" />
    <path
       stroke-linejoin="round"
       stroke-linecap="round"
       stroke-width="${angMarkerLineWidth}"
       stroke="${color}"
       d="m 17,16 7,-7.5 7,7.5" />
  </g>
</svg>`;
            } else {
                console.log("予期しない入力 @angMarker");
                svgMarker = `
<svg 
  viewBox="0 0 48 48" 
  fill="none" 
>
  <g transform="rotate(${ang}, 24, 24)">
    <path
     d="m 36,24.019918 c 0,-8.73 -12,-20.6800002 -12,-20.6800002 0,0 -12,11.9500002 -12,20.6800002 a 12,12 0 0 0 24,0 z"
     fill="none"
     stroke="${color}"
     stroke-linecap="round"
     stroke-linejoin="round"
     stroke-width="${angMarkerLineWidth}" />
  <circle
     cx="24"
     cy="24"
     r="${angMarkerPointRadius}"
     fill="${color}" />
  </g>
</svg>`;
            }

            var divicon = L.divIcon(
                {
                    className: "",
                    iconSize: [4 * radius, 4 * radius],
                    html: svgMarker,
                    iconAnchor: [2 * radius, 2 * radius]
                }
            );
            c = L.marker([lat, lng], { icon: divicon }).addTo(map);

            c.bindPopup(`緯度 : ${lat}<br>経度 : ${lng}<br>値 : ${pow}<br>方位角 : ${ang}`);
            c.on("mouseover", function (e) {
                this.openPopup();
            });
            c.on("mouseout", function (e) {
                this.closePopup();
            });
        }
    };

    function resetPos(lat, lng) {
        if (lat !== "" && lng !== "") {
            if ((-90 <= lat <= 90) && (-180 <= lng <= 180)) {
                map.setView([lat, lng]);
            }
        }
    }

    // データのうち, 電力列における最小・最大値を取得する
    function getMinMax(data, powIndex) {
        let data_T = data[0].map((_, c) => data.map(r => r[c]));
        let parsed_arr = data_T[powIndex].flatMap((v, i) => (i === 0) || (v === "") ? [] : parseFloat(v));
        return [Math.min.apply(null, parsed_arr), Math.max.apply(null, parsed_arr)]
    }
</script>

<!-- その他jQueryでの処理 -->
<script>
    // プロットモーダルでの各入力項目のチェック
    function checkRequiredElementFilled() {
        let filled = true;
        $("#plot-opt-form input:required, #plot-opt-form select:required").each(function (i, e) {
            if ($(e).val() == "" || $(e).val() == null) {
                if (!$(e).prop("disabled")) {
                    filled = false;
                }
            }
        });
        return filled;
    };

    // タイルモーダルでの不透過率の一覧取得
    function getNowOpacity() {
        return $(`#opacity-input-container>.input-container select`).map(function () {
            return $(this).val()
        });
    }

    $(function () {
        // ------ 動作に対するアクション決定系
        // 移動のモーダルウィンドウ関係
        $("a#move-specified-pos").on("click", function () {
            resetPos(
                $("input#lat-input").val(),
                $("input#lng-input").val()
            );
            return false;
        });
        // 不透過率設定へのアクション
        $(".tile-modal-container select").on("change", function () {
            if ($(this).val() != "" && $(this).val() != null) {
                updateTiles($("#opacity-input-container select").map(function () { return $(this).val() }));
            } else {
                updateTiles($("#opacity-input-container select").map(function () { return $(this).val() }));
            }
        });
        // プロットのモーダルウィンドウ関係
        $('.plot-modal-open').on('click', function () {
            $('.plot-modal-container').fadeIn();
            return false;
        });
        $('.plot-modal-close').on('click', function () {
            $('.plot-modal-container').fadeOut();
            return false;
        });
        // 移動のモーダルウィンドウ関係
        $('.move-modal-open').on('click', function () {
            $('.move-modal-container').fadeIn();
            return false;
        });
        $('.move-modal-close').on('click', function () {
            $('.move-modal-container').fadeOut();
            return false;
        });
        // タイルのモーダルウィンドウ関係
        $('.tile-modal-open').on('click', function () {
            $('.tile-modal-container').fadeIn();
            return false;
        });
        $('.tile-modal-close').on('click', function () {
            $('.tile-modal-container').fadeOut();
            return false;
        });

        // プロットのモーダルウィンドウ内要素のアコーディオン
        $("fieldset legend").on("click", function () {
            $(this).nextAll().slideToggle();
            $(this).toggleClass("closed");
        });
        $("#plot-opt-form fieldset:not(.select-column) legend").click();

        // ファイルをドラッグオーバーしたときの処理
        $("#file-input").on("dragenter", function (e) {
            // e.preventDefault();
            $("#file-input-drop-box").addClass("drag-enter")
        });
        $("#file-input").on("dragleave drop", function (e) {
            // e.preventDefault();
            $("#file-input-drop-box").removeClass("drag-enter")
        });

        // 電力の列が入力された際に「描画の設定」: 最小値・最大値のセットボタンを有効化＆挙動追加
        $("#pow-index-selector").on("change", function () {
            if ($(this).val() != "" && $(this).val() != null && !$(this).prop("disabled")) {
                $("#calc-minmax").removeClass("disable").addClass("enable");
            } else {
                $("#calc-minmax").removeClass("enable").addClass("disable");
            }
        });
        $('#calc-minmax').on('click', function () {
            return false;
        });

        // 項目内容に応じて, 決定ボタンを表示する
        $("#plot-opt-form input:required, #plot-opt-form select:required").on("change", function () {
            if (parseInt($("#pow-min-input").val()) > parseInt($("#pow-max-input").val())) {
                $("#decide-button").prop("disabled", true).change();
                return;
            }
            if (!checkRequiredElementFilled()) {
                $("#decide-button").prop("disabled", true).change();
                return;
            }
            $("#decide-button").prop("disabled", false).change();
        });

        // 大小のチェック
        $("#pow-min-input").on("change", function () {
            if (parseInt($("#pow-min-input").val()) > parseInt($("#pow-max-input").val())) {
                $("#pow-max-input").val(parseInt($(this).val()) + 100);
            }
        });
        $("#pow-max-input").on("change", function () {
            if (parseInt($("#pow-min-input").val()) > parseInt($("#pow-max-input").val())) {
                $("#pow-min-input").val(parseInt($(this).val()) - 100);
            }
        });

        // ノイズのカラムの選択時の処理
        $("#noise-index-selector").on("change", function () {
            if ($(this).val() == "" || $(this).val() == null) {
                $("#noise-diff-input").prop("disabled", true).change();
                $("#noise-diff-input").prev().children("span").text("");
            } else {
                $("#noise-diff-input").prop("disabled", false).change();
                $("#noise-diff-input").prev().children("span").text("(必須)");
            }
        });

        // 方位角のカラムを選択時の処理
        $("#angle-index-selector").on("change", function () {
            if ($(this).val() == "" || $(this).val() == null) {
                $("#angle-marker-selector").prop("disabled", true).change();
                $("#angle-marker-lw-input").prop("disabled", true).change();
                $("#angle-marker-pr-input").prop("disabled", true).change();
                $("#angle-marker-selector").prev().children("span").text("");
                $("#angle-marker-lw-input").prev().children("span").text("");
                $("#angle-marker-pr-input").prev().children("span").text("");
            } else {
                $("#angle-marker-selector").prop("disabled", false).change();
                $("#angle-marker-lw-input").prop("disabled", false).change();
                $("#angle-marker-pr-input").prop("disabled", false).change();
                $("#angle-marker-selector").prev().children("span").text("(必須)");
                $("#angle-marker-lw-input").prev().children("span").text("(必須)");
                $("#angle-marker-pr-input").prev().children("span").text("(必須)");
            }
        });

        // 入力フォーム部分の下線部とか文字装飾アニメーション
        $('.input-container>.have-ul').focus(function () {
            $(this).prev().css({ 'color': '#0261c0' });
            $(this).next().addClass("form-underline-focus");
        }).blur(function () {
            $(this).prev().css({ 'color': 'rgb(39, 39, 39)' });
            $(this).next().removeClass("form-underline-focus");
        });

        // マップの透明度に合わせて, レンジバーの透過
        $("#opacity-input").on("input", function () {
            $(this).css("background-color", `rgba(21, 177, 224, ${$(this).val()})`);
        });

        // モーダルのNaNに対するチェックボックスの変更
        $("#plot-nan-input").on("change", function () {
            if ($(this).prop("checked")) {
                $(this).next().text("する");
            } else {
                $(this).next().text("しない");
            }
        });

        // モーダルの円の塗りつぶしに対するチェックボックスの変更
        $("#fill-circle-input").on("change", function () {
            if ($(this).prop("checked")) {
                $(this).next().text("する");
            } else {
                $(this).next().text("しない");
            }
        });

        // モーダルの「ヒートマップの向き」に対するチェックボックスの変更
        $("#reverse-heatmap-input").on("change", function () {
            if ($(this).prop("checked")) {
                $(this).next().text("逆方向");
            } else {
                $(this).next().text("順方向");
            }
        });
    });
</script>